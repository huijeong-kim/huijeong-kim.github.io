<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Type on Dev. note</title><link>http://huijeong-kim.github.io/tags/type/</link><description>Recent content in Type on Dev. note</description><generator>Hugo -- 0.146.0</generator><language>kr</language><lastBuildDate>Sun, 07 May 2023 19:02:30 +0900</lastBuildDate><atom:link href="http://huijeong-kim.github.io/tags/type/index.xml" rel="self" type="application/rss+xml"/><item><title>Exploring Rust Strings</title><link>http://huijeong-kim.github.io/post/2023-05-07-exploring-rust-strings/</link><pubDate>Sun, 07 May 2023 19:02:30 +0900</pubDate><guid>http://huijeong-kim.github.io/post/2023-05-07-exploring-rust-strings/</guid><description>&lt;p>안녕하세요.&lt;/p>
&lt;p>오늘은 Rust의 문자열 개념을 간단하게 알아보고, 코드 작성 시 문자열 관련 혼란스러웠던 포인트들을 정리해 보고자 합니다.&lt;/p>
&lt;p> 
 &lt;/p>
&lt;h1 id="1-string-vs-str">1. String vs. str&lt;/h1>
&lt;p>&lt;code>String&lt;/code> 과 &lt;code>str&lt;/code> 는 모두 &lt;strong>valid&lt;/strong> UTF-8 문자열을 나타냅니다. Invalid UTF-8 데이터로 &lt;code>String&lt;/code> 타입을 생성할 수 없습니다. UTF-8, Unicode 등에 대한 설명은 생략합니다.&lt;/p>
&lt;p>Rust에서는 C와 같이 null-terminating string 개념을 사용하지 않습니다. 대신 &lt;code>String&lt;/code> 타입은 문자열과 그 길이를 갖고 있는 &lt;strong>&amp;ldquo;fat pointer&amp;rdquo;&lt;/strong> 입니다. &amp;ldquo;fat pointer&amp;quot;는 raw pointer과 additional metadata (e.g., length)를 갖고 있는 포인터를 의미합니다.&lt;/p></description></item><item><title>as operator in Rust</title><link>http://huijeong-kim.github.io/post/2023-05-02-rust-as-operator/</link><pubDate>Tue, 02 May 2023 19:00:30 +0900</pubDate><guid>http://huijeong-kim.github.io/post/2023-05-02-rust-as-operator/</guid><description>&lt;p>안녕하세요.&lt;/p>
&lt;p>오늘은 Rust의 &lt;code>as&lt;/code> 를 사용한 type casting에 대해 알아보고자 합니다. C++ 프로그램에서는 잘못된 type 사용 으로 인한 오류를 종종 볼 수 있습니다. &lt;code>uint64_t&lt;/code> 값을 &lt;code>uint32_t&lt;/code> 값에 대입하여 잘못된 값으로 동작하는 경우가 그 예입니다. 조금은 어이 없는 실수이긴 한데, 생각보다 자주 발견됩니다. 이런 류의 버그는 처음 봤을 때 원인을 가늠하기 힘들기도 하지만, 고치기 귀찮거나 어렵기도 합니다. Type 재정의를 사용하지 않는 경우도 많고, 가끔씩은 통일할 필요가 크게 없는 경우도 있고, 의미 상 같은 변수를 모두 찾아내기 힘든 코드들도 종종 있습니다. 테스트를 더 잘 하면 된다고 하지만, 모든 변수에 대해 boundary test를 하는 건 현실적으로 조금 어렵습니다.&lt;/p></description></item></channel></rss>