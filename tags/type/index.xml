<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Type on Dev. note</title><link>http://huijeong-kim.github.io/tags/type/</link><description>Recent content in Type on Dev. note</description><generator>Hugo -- gohugo.io</generator><language>kr</language><lastBuildDate>Sun, 07 May 2023 19:02:30 +0900</lastBuildDate><atom:link href="http://huijeong-kim.github.io/tags/type/index.xml" rel="self" type="application/rss+xml"/><item><title>Exploring Rust Strings</title><link>http://huijeong-kim.github.io/post/2023-05-07-exploring-rust-strings/</link><pubDate>Sun, 07 May 2023 19:02:30 +0900</pubDate><guid>http://huijeong-kim.github.io/post/2023-05-07-exploring-rust-strings/</guid><description>안녕하세요.
오늘은 Rust의 문자열 개념을 간단하게 알아보고, 코드 작성 시 문자열 관련 혼란스러웠던 포인트들을 정리해 보고자 합니다.
1. String vs. str String 과 str 는 모두 valid UTF-8 문자열을 나타냅니다. Invalid UTF-8 데이터로 String 타입을 생성할 수 없습니다. UTF-8, Unicode 등에 대한 설명은 생략합니다.
Rust에서는 C와 같이 null-terminating string 개념을 사용하지 않습니다. 대신 String 타입은 문자열과 그 길이를 갖고 있는 &amp;ldquo;fat pointer&amp;rdquo; 입니다. &amp;ldquo;fat pointer&amp;quot;는 raw pointer과 additional metadata (e.g., length)를 갖고 있는 포인터를 의미합니다.</description></item><item><title>as operator in Rust</title><link>http://huijeong-kim.github.io/post/2023-05-02-rust-as-operator/</link><pubDate>Tue, 02 May 2023 19:00:30 +0900</pubDate><guid>http://huijeong-kim.github.io/post/2023-05-02-rust-as-operator/</guid><description>안녕하세요.
오늘은 Rust의 as 를 사용한 type casting에 대해 알아보고자 합니다. C++ 프로그램에서는 잘못된 type 사용 으로 인한 오류를 종종 볼 수 있습니다. uint64_t 값을 uint32_t 값에 대입하여 잘못된 값으로 동작하는 경우가 그 예입니다. 조금은 어이 없는 실수이긴 한데, 생각보다 자주 발견됩니다. 이런 류의 버그는 처음 봤을 때 원인을 가늠하기 힘들기도 하지만, 고치기 귀찮거나 어렵기도 합니다. Type 재정의를 사용하지 않는 경우도 많고, 가끔씩은 통일할 필요가 크게 없는 경우도 있고, 의미 상 같은 변수를 모두 찾아내기 힘든 코드들도 종종 있습니다.</description></item></channel></rss>