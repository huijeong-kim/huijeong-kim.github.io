<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Quantization: PTQ and QAT | Dev. note</title>
<meta name=keywords content><meta name=description content="양자화(Quantization)는 딥러닝 모델의 weights와 activations 값 표현 정밀도를 낮추는 기법입니다. 일반적으로는 부동소수점(예: 32-bit float, FP32)에서 더 낮은 비트의 정수(예: 8-bit integer, INT8)로 변환하는 과정을 말합니다. 이를 통해 모델 크기를 줄이고, 추론 속도를 높이며, 전력 소모를 감소시킬 수 있어 특히 엣지 디바이스나 모바일 환경에 모델을 배포할 때 유용합니다. 또한 inference에는 고 정밀도가 필요하지 않은 경우가 많아 모델 정확도를 유지할 수 있습니다.
 
PTQ (Post-Training Quantization, 학습 후 양자화)
PTQ는 이미 학습된 부동소수점 모델을 가져와 양자화하는 방식입니다. 학습 과정은 건드리지 않고, 학습이 완료된 모델에 대해 양자화 변환만 수행합니다. 기존 학습된 모델을 그대로 사용하므로 적용이 추가적인 학습이나 학습 파이프라인 수정이 필요 없습니다. 하지만 양자화 과정에서 정보 손실이 발생하여 모델의 정확도가 떨어질 수 있고, 레이어의 오차 전파로 오차 누적 현상이 심해질 수 있습니다."><meta name=author content="Huijeong Kim"><link rel=canonical href=http://huijeong-kim.github.io/post/2025-06-09-quantization/><link crossorigin=anonymous href=../../assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=http://huijeong-kim.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://huijeong-kim.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://huijeong-kim.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://huijeong-kim.github.io/apple-touch-icon.png><link rel=mask-icon href=http://huijeong-kim.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://huijeong-kim.github.io/post/2025-06-09-quantization/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]}}</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js async></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VHBQNPGKKB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VHBQNPGKKB")}</script><meta property="og:url" content="http://huijeong-kim.github.io/post/2025-06-09-quantization/"><meta property="og:site_name" content="Dev. note"><meta property="og:title" content="Quantization: PTQ and QAT"><meta property="og:description" content="양자화(Quantization)는 딥러닝 모델의 weights와 activations 값 표현 정밀도를 낮추는 기법입니다. 일반적으로는 부동소수점(예: 32-bit float, FP32)에서 더 낮은 비트의 정수(예: 8-bit integer, INT8)로 변환하는 과정을 말합니다. 이를 통해 모델 크기를 줄이고, 추론 속도를 높이며, 전력 소모를 감소시킬 수 있어 특히 엣지 디바이스나 모바일 환경에 모델을 배포할 때 유용합니다. 또한 inference에는 고 정밀도가 필요하지 않은 경우가 많아 모델 정확도를 유지할 수 있습니다.
PTQ (Post-Training Quantization, 학습 후 양자화) PTQ는 이미 학습된 부동소수점 모델을 가져와 양자화하는 방식입니다. 학습 과정은 건드리지 않고, 학습이 완료된 모델에 대해 양자화 변환만 수행합니다. 기존 학습된 모델을 그대로 사용하므로 적용이 추가적인 학습이나 학습 파이프라인 수정이 필요 없습니다. 하지만 양자화 과정에서 정보 손실이 발생하여 모델의 정확도가 떨어질 수 있고, 레이어의 오차 전파로 오차 누적 현상이 심해질 수 있습니다."><meta property="og:locale" content="kr"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-06-09T21:32:12+09:00"><meta property="article:modified_time" content="2025-06-09T21:32:12+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Quantization: PTQ and QAT"><meta name=twitter:description content="양자화(Quantization)는 딥러닝 모델의 weights와 activations 값 표현 정밀도를 낮추는 기법입니다. 일반적으로는 부동소수점(예: 32-bit float, FP32)에서 더 낮은 비트의 정수(예: 8-bit integer, INT8)로 변환하는 과정을 말합니다. 이를 통해 모델 크기를 줄이고, 추론 속도를 높이며, 전력 소모를 감소시킬 수 있어 특히 엣지 디바이스나 모바일 환경에 모델을 배포할 때 유용합니다. 또한 inference에는 고 정밀도가 필요하지 않은 경우가 많아 모델 정확도를 유지할 수 있습니다.
 
PTQ (Post-Training Quantization, 학습 후 양자화)
PTQ는 이미 학습된 부동소수점 모델을 가져와 양자화하는 방식입니다. 학습 과정은 건드리지 않고, 학습이 완료된 모델에 대해 양자화 변환만 수행합니다. 기존 학습된 모델을 그대로 사용하므로 적용이 추가적인 학습이나 학습 파이프라인 수정이 필요 없습니다. 하지만 양자화 과정에서 정보 손실이 발생하여 모델의 정확도가 떨어질 수 있고, 레이어의 오차 전파로 오차 누적 현상이 심해질 수 있습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://huijeong-kim.github.io/post/"},{"@type":"ListItem","position":2,"name":"Quantization: PTQ and QAT","item":"http://huijeong-kim.github.io/post/2025-06-09-quantization/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Quantization: PTQ and QAT","name":"Quantization: PTQ and QAT","description":"양자화(Quantization)는 딥러닝 모델의 weights와 activations 값 표현 정밀도를 낮추는 기법입니다. 일반적으로는 부동소수점(예: 32-bit float, FP32)에서 더 낮은 비트의 정수(예: 8-bit integer, INT8)로 변환하는 과정을 말합니다. 이를 통해 모델 크기를 줄이고, 추론 속도를 높이며, 전력 소모를 감소시킬 수 있어 특히 엣지 디바이스나 모바일 환경에 모델을 배포할 때 유용합니다. 또한 inference에는 고 정밀도가 필요하지 않은 경우가 많아 모델 정확도를 유지할 수 있습니다.\nPTQ (Post-Training Quantization, 학습 후 양자화) PTQ는 이미 학습된 부동소수점 모델을 가져와 양자화하는 방식입니다. 학습 과정은 건드리지 않고, 학습이 완료된 모델에 대해 양자화 변환만 수행합니다. 기존 학습된 모델을 그대로 사용하므로 적용이 추가적인 학습이나 학습 파이프라인 수정이 필요 없습니다. 하지만 양자화 과정에서 정보 손실이 발생하여 모델의 정확도가 떨어질 수 있고, 레이어의 오차 전파로 오차 누적 현상이 심해질 수 있습니다.\n","keywords":[],"articleBody":"양자화(Quantization)는 딥러닝 모델의 weights와 activations 값 표현 정밀도를 낮추는 기법입니다. 일반적으로는 부동소수점(예: 32-bit float, FP32)에서 더 낮은 비트의 정수(예: 8-bit integer, INT8)로 변환하는 과정을 말합니다. 이를 통해 모델 크기를 줄이고, 추론 속도를 높이며, 전력 소모를 감소시킬 수 있어 특히 엣지 디바이스나 모바일 환경에 모델을 배포할 때 유용합니다. 또한 inference에는 고 정밀도가 필요하지 않은 경우가 많아 모델 정확도를 유지할 수 있습니다.\nPTQ (Post-Training Quantization, 학습 후 양자화) PTQ는 이미 학습된 부동소수점 모델을 가져와 양자화하는 방식입니다. 학습 과정은 건드리지 않고, 학습이 완료된 모델에 대해 양자화 변환만 수행합니다. 기존 학습된 모델을 그대로 사용하므로 적용이 추가적인 학습이나 학습 파이프라인 수정이 필요 없습니다. 하지만 양자화 과정에서 정보 손실이 발생하여 모델의 정확도가 떨어질 수 있고, 레이어의 오차 전파로 오차 누적 현상이 심해질 수 있습니다.\n작동 방식: 미리 학습된 FP32 모델을 준비, 모델의 가중치를 INT8과 같은 낮은 정밀도로 변환 Activation 값의 경우, 일반적으로 calibration 과정을 통해 값의 범위(최소, 최대)를 결정하고 이를 기반으로 양자화. Weight 값은 이미 모델에 고정된 값이기 때문에 calibration 데이터 없이도 바로 quantize 가능 Quantization 방식: Scale과 Zero-point 양자화는 연속적인 부동소수점 값을 이산적인 정수값으로 표현하는 과정입니다. 이를 위해 가장 일반적으로 사용하는 방식은 Affine Quantization이며, 이 방식은 다음과 같은 수식을 기반으로 합니다:\nx _ i n t = r o u n d ( x _ f p / s c a l e ) + z e r o _ p o i n t x_fp: 부동소수점 값 (float) x_int: 양자화된 정수값 (예: INT8) scale: 부동소수점 → 정수로 변환할 때 사용하는 배율 zero_point: 0을 정수 범위 내에서 표현하기 위한 기준값 이 수식을 기반으로 부동소수점 값을 정수로 압축할 수 있으며, 정수로 연산한 후에는 다시 dequantize 과정을 통해 부동소수점 값으로 복원할 수 있습니다:\nx _ f p ≈ s c a l e × ( x _ i n t - z e r o _ p o i n t ) scale은 보통 해당 텐서의 최대값과 최소값을 기준으로 다음과 같이 계산됩니다:\ns c a l e = ( m a x _ f p - m i n _ f p ) ( m a x _ i n t - m i n _ i n t ) 그리고 zero_point는 일반적으로 다음과 같이 계산되며, 정수 범위 내 가장 가까운 정수로 반올림됩니다:\nz e r o _ p o i n t = r o u n d ( m i n _ i n t - m i n _ f p / s c a l e ) Scale과 zero-point를 구하는 단위는 layer-wise, operator-wise, per-tensor, per-channel 등 다양할 수 있습니다.\nCalibration Calibration은 activation 값의 정규화된 스케일 정보를 얻는 과정입니다. FP 값을 정수에 매핑할 때 필요한 zero_point와 scale 값을 찾습니다. 일반적으로 소량의 대표 입력 데이터셋을 통해 수행됩니다. 이 데이터셋은 전체 학습 데이터의 일부로 구성되며, 모델에 이 데이터를 통과시켜 각 layer의 activation 값 분포를 관찰하고, 해당 분포를 기반으로 quantization에 필요한 scale과 zero-point를 추정합니다. Activation의 최댓값과 최솟값을 측정하여 이를 정수 표현 범위(예: -128 ~ 127)에 맞게 매핑하는 방식이 일반적입니다.\nCalibration 방식은 다음과 같은 기준으로 분류될 수 있습니다.\n어떻게 zero-point/scale 값을 추정하느냐: min-max 방식, percentile 방식 등 어떤 시점에 calibration 값을 적용하느냐: static quant., dynamic quant. activation의 경우 inference 시점에 scale을 계산할 수 있고, 이를 dynamic quantization이라고 말합니다. QAT (Quantization-Aware Training, 양자화 인식 학습) QAT는 모델 학습 과정 중에 양자화로 인한 영향을 미리 시뮬레이션하여, 모델이 양자화된 상태에서도 성능 저하를 최소화하도록 학습하는 방식입니다. 학습 과정에서 양자화 효과를 반영하므로 PTQ에 비해 모델의 정확도를 더 잘 유지할 수 있습니다. 따라서 PTQ 보다 더 낮은 비트로 양자화에도 상대적으로 강인합니다.\n작동 방식: 학습 파이프라인에 “가짜 양자화(Fake Quantization)” 연산을 추가 Forward pass에서는 weight와 activation을 양자화했다가 다시 부동소수점으로 변환(dequantize)하여 양자화로 인한 오차를 모델이 학습하도록 함 Backward pass에서는 부동소수점 값을 사용하여 계산하고 가중치를 업데이트 QAT vs. Low-precision Floating-Point 그렇다면 training 중 양자화 시뮬레이션을 하는 것과 더 낮은 정밀도의 부동소수점(Low Precision Floating Point)를 사용하는 것의 차이점은 무엇일까요.\nQAT - Fake Quantization Fake quantization은 실제 정수 연산을 하지 않으면서도, 정수로 양자화했을 때 발생할 수 있는 정보 손실을 시뮬레이션하는 기법입니다. 훈련은 여전히 부동소수점(float)으로 진행되지만, 정수 표현에 맞게 값의 범위를 제한하고 반올림(rounding), 클램핑(clamping, 값의 범위를 제한)을 적용하는 연산을 삽입함으로써 정수 양자화와 유사한 조건에서 모델이 학습되도록 유도, 양자화 오차에 강인해지도록 학습됩니다. 역전파 시에는 여전히 고정밀도(FP32) 값을 사용합니다.\nx _ f p 3 2 → c l a m p ( m i n , m a x ) → r o u n d ( ( x - z e r o _ p o i n t ) / s c a l e ) → d e q u a n t i z e 이렇게 학습된 모델은 나중에 실제 정수 연산만 지원하는 하드웨어(예: NPU, 특정 DSP, Edge TPU 등)에서 실행될 때 원래 FP32 모델과 유사한 정확도를 유지할 가능성이 커집니다. 즉, QAT는 INT8 추론을 위한 최적화 기법입니다. 훈련이 끝난 후 실제 추론시에는 INT8 타입으로 동작합니다.\n낮은 정밀도 부동소수점(Low-Precision Floating-Point) 단순히 낮은 정밀도의 부동소수점(예: FP16, bfloat16)을 사용하는 것은 여전히 부동소수점 연산의 범주에 속합니다. 이는 메모리 사용량을 줄입니다. 정수 변환에서 오는 비선형적인 정보 손실(반올림, 클램핑)을 직접적으로 시뮬레이션하지는 않습니다. 낮은 정밀도로 인한 수치적 불안정성을 관리하기 위해 혼합 정밀도 학습(Mixed Precision Training)과 같은 기법이 사용될 수 있습니다.\n정수 연산의 장점 QAT 를 통해 INT8 연산을 할 경우, 모델의 크기가 FP32 대비 약 4배 감소합니다. 많은 하드웨어(CPU, GPU, NPU, TPU 등)에는 INT8 정수 연산에 특화된 가속 유닛이 있어 FP32나 FP16 연산보다 훨씬 빠른 추론 속도를 제공할 수 있습니다. 또한 정수 연산은 부동소수점 연산보다 일반적으로 전력 소모가 적다는 장점도 갖고 있습니다.\nQAT 사용은 INT8 하드웨어 연산기의 이점에 달려있는 듯 합니다. INT8 연산기는 하드웨어 설계 측면에서 FP16 연산기에 비해 여러 가지 이점을 가집니다. 회로 구조가 단순하고 작기 때문에 실리콘 면적과 전력 소비가 적습니다. TPU 논문은 TPU가 성공한 이유 중 하나를 양자화된 애플리케이션에 의해 8비트 정수가 사용되었다는 점을 뽑습니다. 8비트 정수 곱셈은 IEEE 754 16비트 부동 소수점 곱셈보다 에너지 소모가 6배 적고 면적이 6배 작으며, 정수 덧셈의 경우 에너지에서 13배, 면적에서 38배 유리하다고 합니다.\n애초에 정수 타입으로 training 할 수 없을까?\n머신 러닝의 gradient 연산 때문에 “정수 기반 학습\"을 하기는 어렵고 비효율적입니다. 학습은 FP32/FP16으로 추론만 INT8, INT4 등으로 하는 경우가 많다고 합니다.\nReferences Towards int8 inference 우아한형제들 기술블로그 - 로봇 ML 모델의 경량화 2부 IBM - What is Quantization Aware Training? MathWorks - What Is int8 Quantization and Why Is It Popular for Deep Neural Networks? In-Datacenter Performance Analysis of a Tensor Processing Unit ","wordCount":"1007","inLanguage":"en","datePublished":"2025-06-09T21:32:12+09:00","dateModified":"2025-06-09T21:32:12+09:00","author":{"@type":"Person","name":"Huijeong Kim"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://huijeong-kim.github.io/post/2025-06-09-quantization/"},"publisher":{"@type":"Organization","name":"Dev. note","logo":{"@type":"ImageObject","url":"http://huijeong-kim.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://huijeong-kim.github.io/ accesskey=h title="Dev. note (Alt + H)">Dev. note</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://huijeong-kim.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://huijeong-kim.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=http://huijeong-kim.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://huijeong-kim.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://huijeong-kim.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://huijeong-kim.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Quantization: PTQ and QAT</h1><div class=post-meta><span title='2025-06-09 21:32:12 +0900 +0900'>2025-06-09</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1007 words&nbsp;·&nbsp;Huijeong Kim</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#ptq-post-training-quantization-%ed%95%99%ec%8a%b5-%ed%9b%84-%ec%96%91%ec%9e%90%ed%99%94 aria-label="PTQ (Post-Training Quantization, 학습 후 양자화)">PTQ (Post-Training Quantization, 학습 후 양자화)</a><ul><li><a href=#quantization-%eb%b0%a9%ec%8b%9d-scale%ea%b3%bc-zero-point aria-label="Quantization 방식: Scale과 Zero-point">Quantization 방식: Scale과 Zero-point</a></li><li><a href=#calibration aria-label=Calibration>Calibration</a></li></ul></li><li><a href=#qat-quantization-aware-training-%ec%96%91%ec%9e%90%ed%99%94-%ec%9d%b8%ec%8b%9d-%ed%95%99%ec%8a%b5 aria-label="QAT (Quantization-Aware Training, 양자화 인식 학습)">QAT (Quantization-Aware Training, 양자화 인식 학습)</a></li><li><a href=#qat-vs-low-precision-floating-point aria-label="QAT vs. Low-precision Floating-Point">QAT vs. Low-precision Floating-Point</a><ul><li><a href=#qat---fake-quantization aria-label="QAT - Fake Quantization">QAT - Fake Quantization</a></li><li><a href=#%eb%82%ae%ec%9d%80-%ec%a0%95%eb%b0%80%eb%8f%84-%eb%b6%80%eb%8f%99%ec%86%8c%ec%88%98%ec%a0%90low-precision-floating-point aria-label="낮은 정밀도 부동소수점(Low-Precision Floating-Point)">낮은 정밀도 부동소수점(Low-Precision Floating-Point)</a></li><li><a href=#%ec%a0%95%ec%88%98-%ec%97%b0%ec%82%b0%ec%9d%98-%ec%9e%a5%ec%a0%90 aria-label="정수 연산의 장점">정수 연산의 장점</a></li></ul></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><p>양자화(Quantization)는 딥러닝 모델의 weights와 activations 값 표현 정밀도를 낮추는 기법입니다. 일반적으로는 부동소수점(예: 32-bit float, FP32)에서 더 낮은 비트의 정수(예: 8-bit integer, INT8)로 변환하는 과정을 말합니다. 이를 통해 모델 크기를 줄이고, 추론 속도를 높이며, 전력 소모를 감소시킬 수 있어 특히 엣지 디바이스나 모바일 환경에 모델을 배포할 때 유용합니다. 또한 inference에는 고 정밀도가 필요하지 않은 경우가 많아 모델 정확도를 유지할 수 있습니다.</p><p> </p><h2 id=ptq-post-training-quantization-학습-후-양자화>PTQ (Post-Training Quantization, 학습 후 양자화)<a hidden class=anchor aria-hidden=true href=#ptq-post-training-quantization-학습-후-양자화>#</a></h2><p><strong>PTQ</strong>는 <strong>이미 학습된 부동소수점 모델을 가져와 양자화</strong>하는 방식입니다. 학습 과정은 건드리지 않고, 학습이 완료된 모델에 대해 양자화 변환만 수행합니다. 기존 학습된 모델을 그대로 사용하므로 적용이 추가적인 학습이나 학습 파이프라인 수정이 필요 없습니다. 하지만 양자화 과정에서 정보 손실이 발생하여 모델의 정확도가 떨어질 수 있고, 레이어의 오차 전파로 오차 누적 현상이 심해질 수 있습니다.</p><ul><li><strong>작동 방식</strong>:<ul><li>미리 학습된 FP32 모델을 준비, 모델의 가중치를 INT8과 같은 낮은 정밀도로 변환</li><li>Activation 값의 경우, 일반적으로 calibration 과정을 통해 값의 범위(최소, 최대)를 결정하고 이를 기반으로 양자화.</li><li>Weight 값은 이미 모델에 고정된 값이기 때문에 calibration 데이터 없이도 바로 quantize 가능</li></ul></li></ul><p> </p><h3 id=quantization-방식-scale과-zero-point>Quantization 방식: Scale과 Zero-point<a hidden class=anchor aria-hidden=true href=#quantization-방식-scale과-zero-point>#</a></h3><p>양자화는 연속적인 부동소수점 값을 이산적인 정수값으로 표현하는 과정입니다. 이를 위해 가장 일반적으로 사용하는 방식은 Affine Quantization이며, 이 방식은 다음과 같은 수식을 기반으로 합니다:</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 328 25"><g transform="translate(8,16)"><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">x</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="16" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="24" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="32" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="48" y="4" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="64" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="72" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="80" y="4" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="88" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="96" y="4" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="104" y="4" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="112" y="4" fill="currentcolor" style="font-size:1em">x</text><text text-anchor="middle" x="120" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="136" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="152" y="4" fill="currentcolor" style="font-size:1em">/</text><text text-anchor="middle" x="168" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="176" y="4" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="184" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="192" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="200" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="208" y="4" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="224" y="4" fill="currentcolor" style="font-size:1em">+</text><text text-anchor="middle" x="240" y="4" fill="currentcolor" style="font-size:1em">z</text><text text-anchor="middle" x="248" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="256" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="264" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="272" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="280" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="288" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="296" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="304" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="312" y="4" fill="currentcolor" style="font-size:1em">t</text></g></svg></div><ul><li>x_fp: 부동소수점 값 (float)</li><li>x_int: 양자화된 정수값 (예: INT8)</li><li>scale: 부동소수점 → 정수로 변환할 때 사용하는 배율</li><li>zero_point: 0을 정수 범위 내에서 표현하기 위한 기준값</li></ul><p>이 수식을 기반으로 부동소수점 값을 정수로 압축할 수 있으며, 정수로 연산한 후에는 다시 dequantize 과정을 통해 부동소수점 값으로 복원할 수 있습니다:</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 288 25"><g transform="translate(8,16)"><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">x</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="16" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="24" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="40" y="4" fill="currentcolor" style="font-size:1em">≈</text><text text-anchor="middle" x="56" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="64" y="4" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="72" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="80" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="88" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="104" y="4" fill="currentcolor" style="font-size:1em">×</text><text text-anchor="middle" x="120" y="4" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">x</text><text text-anchor="middle" x="136" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="144" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="152" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="160" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="176" y="4" fill="currentcolor" style="font-size:1em">-</text><text text-anchor="middle" x="192" y="4" fill="currentcolor" style="font-size:1em">z</text><text text-anchor="middle" x="200" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="208" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="216" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="224" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="232" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="240" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="248" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="256" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="264" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="272" y="4" fill="currentcolor" style="font-size:1em">)</text></g></svg></div><p>scale은 보통 해당 텐서의 최대값과 최소값을 기준으로 다음과 같이 계산됩니다:</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 384 25"><g transform="translate(8,16)"><path d="M204 8V24" fill="none" stroke="currentcolor"/><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="16" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="24" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="32" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="48" y="4" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="64" y="4" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="72" y="4" fill="currentcolor" style="font-size:1em">m</text><text text-anchor="middle" x="80" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="88" y="4" fill="currentcolor" style="font-size:1em">x</text><text text-anchor="middle" x="96" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="104" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="112" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">-</text><text text-anchor="middle" x="144" y="4" fill="currentcolor" style="font-size:1em">m</text><text text-anchor="middle" x="152" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="160" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="168" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="176" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="184" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="192" y="4" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="224" y="4" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="232" y="4" fill="currentcolor" style="font-size:1em">m</text><text text-anchor="middle" x="240" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="248" y="4" fill="currentcolor" style="font-size:1em">x</text><text text-anchor="middle" x="256" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="264" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="272" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="280" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="296" y="4" fill="currentcolor" style="font-size:1em">-</text><text text-anchor="middle" x="312" y="4" fill="currentcolor" style="font-size:1em">m</text><text text-anchor="middle" x="320" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="328" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="336" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="344" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="352" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="360" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="368" y="4" fill="currentcolor" style="font-size:1em">)</text></g></svg></div><p>그리고 zero_point는 일반적으로 다음과 같이 계산되며, 정수 범위 내 가장 가까운 정수로 반올림됩니다:</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 360 25"><g transform="translate(8,16)"><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">z</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="16" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="24" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="32" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="40" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="48" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="56" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="64" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="72" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="88" y="4" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="104" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="112" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="120" y="4" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="136" y="4" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="144" y="4" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="152" y="4" fill="currentcolor" style="font-size:1em">m</text><text text-anchor="middle" x="160" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="168" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="176" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="184" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="192" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="200" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="216" y="4" fill="currentcolor" style="font-size:1em">-</text><text text-anchor="middle" x="232" y="4" fill="currentcolor" style="font-size:1em">m</text><text text-anchor="middle" x="240" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="248" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="256" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="264" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="272" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="288" y="4" fill="currentcolor" style="font-size:1em">/</text><text text-anchor="middle" x="304" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="312" y="4" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="320" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="328" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="336" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="344" y="4" fill="currentcolor" style="font-size:1em">)</text></g></svg></div><p> </p><p>Scale과 zero-point를 구하는 단위는 layer-wise, operator-wise, per-tensor, per-channel 등 다양할 수 있습니다.</p><p> </p><h3 id=calibration>Calibration<a hidden class=anchor aria-hidden=true href=#calibration>#</a></h3><p>Calibration은 activation 값의 정규화된 스케일 정보를 얻는 과정입니다. FP 값을 정수에 매핑할 때 필요한 zero_point와 scale 값을 찾습니다. 일반적으로 소량의 대표 입력 데이터셋을 통해 수행됩니다. 이 데이터셋은 전체 학습 데이터의 일부로 구성되며, 모델에 이 데이터를 통과시켜 각 layer의 activation 값 분포를 관찰하고, 해당 분포를 기반으로 quantization에 필요한 <strong>scale</strong>과 <strong>zero-point</strong>를 추정합니다. Activation의 최댓값과 최솟값을 측정하여 이를 정수 표현 범위(예: -128 ~ 127)에 맞게 매핑하는 방식이 일반적입니다.</p><p>Calibration 방식은 다음과 같은 기준으로 분류될 수 있습니다.</p><ul><li>어떻게 zero-point/scale 값을 추정하느냐: min-max 방식, percentile 방식 등</li><li>어떤 시점에 calibration 값을 적용하느냐: static quant., dynamic quant.<ul><li>activation의 경우 inference 시점에 scale을 계산할 수 있고, 이를 dynamic quantization이라고 말합니다.</li></ul></li></ul><p> </p><h2 id=qat-quantization-aware-training-양자화-인식-학습>QAT (Quantization-Aware Training, 양자화 인식 학습)<a hidden class=anchor aria-hidden=true href=#qat-quantization-aware-training-양자화-인식-학습>#</a></h2><p><strong>QAT</strong>는 <strong>모델 학습 과정 중에 양자화로 인한 영향을 미리 시뮬레이션</strong>하여, 모델이 양자화된 상태에서도 성능 저하를 최소화하도록 학습하는 방식입니다. 학습 과정에서 양자화 효과를 반영하므로 PTQ에 비해 모델의 정확도를 더 잘 유지할 수 있습니다. 따라서 PTQ 보다 더 낮은 비트로 양자화에도 상대적으로 강인합니다.</p><ul><li><strong>작동 방식</strong>:<ul><li>학습 파이프라인에 &ldquo;가짜 양자화(Fake Quantization)&rdquo; 연산을 추가</li><li>Forward pass에서는 weight와 activation을 양자화했다가 다시 부동소수점으로 변환(dequantize)하여 양자화로 인한 오차를 모델이 학습하도록 함</li><li>Backward pass에서는 부동소수점 값을 사용하여 계산하고 가중치를 업데이트</li></ul></li></ul><p> </p><h2 id=qat-vs-low-precision-floating-point>QAT vs. Low-precision Floating-Point<a hidden class=anchor aria-hidden=true href=#qat-vs-low-precision-floating-point>#</a></h2><p>그렇다면 training 중 양자화 시뮬레이션을 하는 것과 더 낮은 정밀도의 부동소수점(Low Precision Floating Point)를 사용하는 것의 차이점은 무엇일까요.</p><p> </p><h3 id=qat---fake-quantization>QAT - Fake Quantization<a hidden class=anchor aria-hidden=true href=#qat---fake-quantization>#</a></h3><p>Fake quantization은 실제 정수 연산을 하지 않으면서도, 정수로 양자화했을 때 발생할 수 있는 정보 손실을 시뮬레이션하는 기법입니다. 훈련은 여전히 부동소수점(float)으로 진행되지만, 정수 표현에 맞게 값의 범위를 제한하고 반올림(rounding), 클램핑(clamping, 값의 범위를 제한)을 적용하는 연산을 삽입함으로써 <strong>정수 양자화와 유사한 조건</strong>에서 모델이 학습되도록 유도, 양자화 오차에 강인해지도록 학습됩니다. 역전파 시에는 여전히 고정밀도(FP32) 값을 사용합니다.</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 576 25"><g transform="translate(8,16)"><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">x</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="16" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="24" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="32" y="4" fill="currentcolor" style="font-size:1em">3</text><text text-anchor="middle" x="40" y="4" fill="currentcolor" style="font-size:1em">2</text><text text-anchor="middle" x="56" y="4" fill="currentcolor" style="font-size:1em">→</text><text text-anchor="middle" x="72" y="4" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="80" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="88" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="96" y="4" fill="currentcolor" style="font-size:1em">m</text><text text-anchor="middle" x="104" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="112" y="4" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="120" y="4" fill="currentcolor" style="font-size:1em">m</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="136" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="144" y="4" fill="currentcolor" style="font-size:1em">,</text><text text-anchor="middle" x="160" y="4" fill="currentcolor" style="font-size:1em">m</text><text text-anchor="middle" x="168" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="176" y="4" fill="currentcolor" style="font-size:1em">x</text><text text-anchor="middle" x="184" y="4" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="200" y="4" fill="currentcolor" style="font-size:1em">→</text><text text-anchor="middle" x="216" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="224" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="232" y="4" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="240" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="248" y="4" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="256" y="4" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="264" y="4" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="272" y="4" fill="currentcolor" style="font-size:1em">x</text><text text-anchor="middle" x="288" y="4" fill="currentcolor" style="font-size:1em">-</text><text text-anchor="middle" x="304" y="4" fill="currentcolor" style="font-size:1em">z</text><text text-anchor="middle" x="312" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="320" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="328" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="336" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="344" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="352" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="360" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="368" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="376" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="384" y="4" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="400" y="4" fill="currentcolor" style="font-size:1em">/</text><text text-anchor="middle" x="416" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="424" y="4" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="432" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="440" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="448" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="456" y="4" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="472" y="4" fill="currentcolor" style="font-size:1em">→</text><text text-anchor="middle" x="488" y="4" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="496" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="504" y="4" fill="currentcolor" style="font-size:1em">q</text><text text-anchor="middle" x="512" y="4" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="520" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="528" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="536" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="544" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="552" y="4" fill="currentcolor" style="font-size:1em">z</text><text text-anchor="middle" x="560" y="4" fill="currentcolor" style="font-size:1em">e</text></g></svg></div><p>이렇게 학습된 모델은 나중에 실제 정수 연산만 지원하는 하드웨어(예: NPU, 특정 DSP, Edge TPU 등)에서 실행될 때 원래 FP32 모델과 유사한 정확도를 유지할 가능성이 커집니다. 즉, QAT는 <strong>INT8 추론을 위한 최적화</strong> 기법입니다. 훈련이 끝난 후 실제 추론시에는 INT8 타입으로 동작합니다.</p><p> </p><h3 id=낮은-정밀도-부동소수점low-precision-floating-point>낮은 정밀도 부동소수점(Low-Precision Floating-Point)<a hidden class=anchor aria-hidden=true href=#낮은-정밀도-부동소수점low-precision-floating-point>#</a></h3><p>단순히 낮은 정밀도의 부동소수점(예: FP16, bfloat16)을 사용하는 것은 여전히 <strong>부동소수점 연산</strong>의 범주에 속합니다. 이는 메모리 사용량을 줄입니다. 정수 변환에서 오는 비선형적인 정보 손실(반올림, 클램핑)을 직접적으로 시뮬레이션하지는 않습니다. 낮은 정밀도로 인한 수치적 불안정성을 관리하기 위해 혼합 정밀도 학습(Mixed Precision Training)과 같은 기법이 사용될 수 있습니다.</p><p> </p><h3 id=정수-연산의-장점>정수 연산의 장점<a hidden class=anchor aria-hidden=true href=#정수-연산의-장점>#</a></h3><p>QAT 를 통해 INT8 연산을 할 경우, 모델의 크기가 FP32 대비 약 4배 감소합니다. 많은 하드웨어(CPU, GPU, NPU, TPU 등)에는 INT8 정수 연산에 특화된 가속 유닛이 있어 FP32나 FP16 연산보다 훨씬 빠른 추론 속도를 제공할 수 있습니다. 또한 정수 연산은 부동소수점 연산보다 일반적으로 전력 소모가 적다는 장점도 갖고 있습니다.</p><p>QAT 사용은 INT8 하드웨어 연산기의 이점에 달려있는 듯 합니다. INT8 연산기는 하드웨어 설계 측면에서 FP16 연산기에 비해 여러 가지 이점을 가집니다. 회로 구조가 단순하고 작기 때문에 실리콘 면적과 전력 소비가 적습니다. <a href=https://arxiv.org/pdf/1704.04760>TPU 논문</a>은 TPU가 성공한 이유 중 하나를 양자화된 애플리케이션에 의해 8비트 정수가 사용되었다는 점을 뽑습니다. 8비트 정수 곱셈은 IEEE 754 16비트 부동 소수점 곱셈보다 에너지 소모가 6배 적고 면적이 6배 작으며, 정수 덧셈의 경우 에너지에서 13배, 면적에서 38배 유리하다고 합니다.</p><p> </p><blockquote><p>애초에 정수 타입으로 training 할 수 없을까?</p><p>머신 러닝의 gradient 연산 때문에 &ldquo;정수 기반 학습"을 하기는 어렵고 비효율적입니다. 학습은 FP32/FP16으로 추론만 INT8, INT4 등으로 하는 경우가 많다고 합니다.</p></blockquote><p> </p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://www.nvidia.com/en-us/on-demand/session/gtcspring22-s41440/>Towards int8 inference</a></li><li><a href=https://techblog.woowahan.com/21176/>우아한형제들 기술블로그 - 로봇 ML 모델의 경량화 2부</a></li><li><a href=https://www.ibm.com/think/topics/quantization-aware-training>IBM - What is Quantization Aware Training?</a></li><li><a href=https://kr.mathworks.com/company/technical-articles/what-is-int8-quantization-and-why-is-it-popular-for-deep-neural-networks.html>MathWorks - What Is int8 Quantization and Why Is It Popular for Deep Neural Networks?</a></li><li><a href=https://arxiv.org/pdf/1704.04760>In-Datacenter Performance Analysis of a Tensor Processing Unit</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=http://huijeong-kim.github.io/post/2025-05-26-transformer-model-workload-analysis/><span class=title>Next »</span><br><span>Transformer Model Workload Analysis</span></a></nav></footer><script src=https://utteranc.es/client.js repo=huijeong-kim/huijeong-kim.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=http://huijeong-kim.github.io/>Dev. note</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>