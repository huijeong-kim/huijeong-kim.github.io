<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust Async Programming | Dev. note</title>
<meta name=keywords content="async rust"><meta name=description content="오늘은 Rust에서 제공하는 Asynchronous Programming 관련 feature들에 대해 정리하면서, async 관련 포스트를 쓸 때 마다 사용되는 단어들, async, future, runtime, executor에 대해 정리해 보겠습니다. 오늘은 유독 내용이 추상적인 느낌에 부족한 부분이 많은 것 같은데, 틀린 부분이나 부족한 부분이 있다면 코멘트 남겨 주세요 :)
 
 
Asynchronous Programming

Async book에는 Asynchronous programming이 다음과 같이 정의되어 있습니다.
 

Asynchronous programming, or async for short, is a concurrent programming model supported by an increasing number of programming languages. It lets you run a large number of concurrent tasks on a small number of OS threads, while preserving much of the look and feel of ordinary synchronous programming, through the async/await syntax."><meta name=author content="Huijeong Kim"><link rel=canonical href=http://huijeong-kim.github.io/post/2022-09-11-rust-async-programming/><link crossorigin=anonymous href=../../assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=http://huijeong-kim.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://huijeong-kim.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://huijeong-kim.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://huijeong-kim.github.io/apple-touch-icon.png><link rel=mask-icon href=http://huijeong-kim.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://huijeong-kim.github.io/post/2022-09-11-rust-async-programming/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]}}</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js async></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VHBQNPGKKB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VHBQNPGKKB")}</script><meta property="og:url" content="http://huijeong-kim.github.io/post/2022-09-11-rust-async-programming/"><meta property="og:site_name" content="Dev. note"><meta property="og:title" content="Rust Async Programming"><meta property="og:description" content="오늘은 Rust에서 제공하는 Asynchronous Programming 관련 feature들에 대해 정리하면서, async 관련 포스트를 쓸 때 마다 사용되는 단어들, async, future, runtime, executor에 대해 정리해 보겠습니다. 오늘은 유독 내용이 추상적인 느낌에 부족한 부분이 많은 것 같은데, 틀린 부분이나 부족한 부분이 있다면 코멘트 남겨 주세요 :)
Asynchronous Programming Async book에는 Asynchronous programming이 다음과 같이 정의되어 있습니다.
Asynchronous programming, or async for short, is a concurrent programming model supported by an increasing number of programming languages. It lets you run a large number of concurrent tasks on a small number of OS threads, while preserving much of the look and feel of ordinary synchronous programming, through the async/await syntax."><meta property="og:locale" content="kr"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-09-11T18:53:04+09:00"><meta property="article:modified_time" content="2022-09-11T18:53:04+09:00"><meta property="article:tag" content="Async Rust"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust Async Programming"><meta name=twitter:description content="오늘은 Rust에서 제공하는 Asynchronous Programming 관련 feature들에 대해 정리하면서, async 관련 포스트를 쓸 때 마다 사용되는 단어들, async, future, runtime, executor에 대해 정리해 보겠습니다. 오늘은 유독 내용이 추상적인 느낌에 부족한 부분이 많은 것 같은데, 틀린 부분이나 부족한 부분이 있다면 코멘트 남겨 주세요 :)
 
 
Asynchronous Programming

Async book에는 Asynchronous programming이 다음과 같이 정의되어 있습니다.
 

Asynchronous programming, or async for short, is a concurrent programming model supported by an increasing number of programming languages. It lets you run a large number of concurrent tasks on a small number of OS threads, while preserving much of the look and feel of ordinary synchronous programming, through the async/await syntax."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://huijeong-kim.github.io/post/"},{"@type":"ListItem","position":2,"name":"Rust Async Programming","item":"http://huijeong-kim.github.io/post/2022-09-11-rust-async-programming/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust Async Programming","name":"Rust Async Programming","description":"오늘은 Rust에서 제공하는 Asynchronous Programming 관련 feature들에 대해 정리하면서, async 관련 포스트를 쓸 때 마다 사용되는 단어들, async, future, runtime, executor에 대해 정리해 보겠습니다. 오늘은 유독 내용이 추상적인 느낌에 부족한 부분이 많은 것 같은데, 틀린 부분이나 부족한 부분이 있다면 코멘트 남겨 주세요 :)\nAsynchronous Programming Async book에는 Asynchronous programming이 다음과 같이 정의되어 있습니다.\nAsynchronous programming, or async for short, is a concurrent programming model supported by an increasing number of programming languages. It lets you run a large number of concurrent tasks on a small number of OS threads, while preserving much of the look and feel of ordinary synchronous programming, through the async/await syntax.\n","keywords":["async rust"],"articleBody":"오늘은 Rust에서 제공하는 Asynchronous Programming 관련 feature들에 대해 정리하면서, async 관련 포스트를 쓸 때 마다 사용되는 단어들, async, future, runtime, executor에 대해 정리해 보겠습니다. 오늘은 유독 내용이 추상적인 느낌에 부족한 부분이 많은 것 같은데, 틀린 부분이나 부족한 부분이 있다면 코멘트 남겨 주세요 :)\nAsynchronous Programming Async book에는 Asynchronous programming이 다음과 같이 정의되어 있습니다.\nAsynchronous programming, or async for short, is a concurrent programming model supported by an increasing number of programming languages. It lets you run a large number of concurrent tasks on a small number of OS threads, while preserving much of the look and feel of ordinary synchronous programming, through the async/await syntax.\n중요 포인트는 두 가지 일 것 같습니다.\nOS thread 수와 관계 없이 task들을 concurrent하게 실행시킬 수 있게 하는 프로그래밍 모델이다 async/await syntax를 사용하여 기존의 synchronous programming과 비슷한 look \u0026 feel을 준다 Concurrent Execution Application의 task를 concurrent하게 실행하는 방법으로 가장 먼저 multi-threading을 떠올릴 수 있습니다. 가장 단순하게는, 병렬 실행할 task 마다 새로운 thread를 생성하고 그 thread에서 task를 실행시켜볼 수 있을 것입니다. std::thread를 사용하면 native OS thread를 생성 및 시작할 수 있습니다.\n하지만 OS thread 를 사용하여 task를 병렬 실행하면 OS 의 제약 내에서 thread를 사용해야 합니다. 단일 process 당 만들 수 있는 최대 thread 수가 제한되어 있고, thread 생성 시 발생하는 overhead, thread pool 관리 등 고려 해야 할 점이 많을 것 입니다.\n많은 프로그래밍 언어에서는 Green Thread와 같은 OS thread 위에서 동작하는 virtual thread와 이 virtual thread를 실행시키는 환경, Runtime을 제공합니다. 이를 사용하면 OS thread의 제약 없이 task parallelism을 구현할 수 있고 개발자가 직접 코드에서 thread를 다루지 않아도 됩니다.\n하지만 Rust의 경우, Green Thread 혹은 Built-in Runtime을 제공하지 않습니다. Async/Await syntax만 제공합니다. 이는 의도적인 디자인으로, 어플리케이션의 workload 에 따라 적합한(성능이 좋은) Runtime은 다를 수 있기 때문 입니다. Rust에는 다양한 Runtime Library들이 존재하고, 개발자는 이 중 application에 적합한 Runtime을 선택하여 async task를 실행시킬 수 있습니다.\nAsync/Await Rust 언어에서 제공하는 Async/await syntax에 대해 간단히 알아보고, 이 것이 Runtime에서 실행 되는 방식을 이어서 알아 보겠습니다.\nThe Book에서 정의한 관련 키워드들은 다음과 같습니다.\nasync - return a Future instead of blocking the current thread await - suspend execution until the result of a Future is ready async는 Future를 리턴하는 asynchronous 동작(현재 thread를 blocking하지 않는 동작)을 의미하고, Future는 Runtime에서 실행될 수 있는 trait 입니다. async 키워드를 사용해 function, block expression, closure를 Future로 만들 수 있습니다. Future trait이 Runtime에서 어떻게 사용 되는지는 뒤에서 간단히 설명하겠습니다.\n다음은 async func, async block, async closure를 만들어 실행시키는 간단한 코드입니다. 기존의 function, block, closure에 async 키워드를 추가하였고, 이를 실행시킬 Runtime으로는 futures crate를 사용했습니다. 각 Future들은 futures::executor::block_on에 의해 실행됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 use futures::executor; async fn async_func() { println!(\"async_func\"); } fn main() { let future1 = async_func(); let future2 = async { println!(\"async block\"); }; let async_closure = || async { println!(\"async closure\"); }; let future3 = async_closure(); executor::block_on(future3); executor::block_on(future2); executor::block_on(future1); } 출력 결과\n1 2 3 async closure async block async_func await는 Future의 동작이 완료되기를 기다릴 때 사용합니다. async 안에서만 사용될 수 있습니다. 다음은 3개의 task, 1) learn_song, 2) sing_song, 3) dance가 주어졌을 때, sing_song과 dance는 learn_song이 완료된 후에 실행되도록 하는 예제 코드입니다. sing_song, dance를 실행시키기 전에 learn_song().await를 사용하여 동작 완료를 기다립니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 struct Song(String); async fn learn_song() -\u003e Song { println!(\"Learn song!\"); Song(String::from(\"Hype boy\")) } async fn dance(song: \u0026Song) { println!(\"Dance to {}!!\", song.0); } async fn sing_song(song: \u0026Song) { println!(\"Sing a song!! {}\", song.0) } fn main() { futures::executor::block_on(async { let song = learn_song().await; let f1 = sing_song(\u0026song); let f2 = dance(\u0026song); futures::join!(f1, f2); }); } 실행 결과\n1 2 3 Learn song! Sing a song!! Hype boy Dance to Hype boy!! await을 사용하여 ‘기다리는’ 동작은 현재 thread를 blocking 하지 않고 동작을 yield 하는 방식으로 이루어집니다. 위의 예제에서는 그 동작이 잘 보이지 않을 수 있지만, I/O intensive application을 생각해 보면 이해하기 쉬울 것 입니다.\n다음 예제는 rust의 대표적인 Runtime인 tokio를 사용한 TCP I/O 예시입니다. tokio runtime 생성 시 new_current_thread을 사용하여 현재 thread(단일 thread)만 사용하도록 했습니다. 단일 thread에서 Server 동작과 Client 동작 둘 다를 실행하고 있지만, Server 동작을 하는 async block에서 TcpListner가 accept()를 기다리는(await) 동안 thread를 blocking 하지 않고 동작을 yield 하므로 Client 동작의 async block에서 불리는 connect()가 실행될 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 use tokio::io::{self, AsyncReadExt, AsyncWriteExt}; use tokio::net::{TcpStream, TcpListener}; fn main() { tokio::runtime::Builder::new_current_thread() .enable_all() .build() .unwrap() .block_on(async { let addr = \"127.0.0.1:6142\"; let server = tokio::spawn(async move { let listener = TcpListener::bind(\u0026addr).await?; loop { let (mut socket, _) = listener.accept().await?; let mut buf = vec![0; 1024]; match socket.read(\u0026mut buf).await { Ok(n) =\u003e { println!(\"{:?}\", buf); } _ =\u003e { return Ok::\u003c_, io::Error\u003e(()); } } } Ok::\u003c_, io::Error\u003e(()) }); let client = tokio::spawn(async move { let socket = TcpStream::connect(\u0026addr).await?; let (mut rd, mut wr) = io::split(socket); wr.write_all(b\"hello\\r\\n\").await?; wr.write_all(b\"world\\r\\n\").await?; Ok::\u003c_, io::Error\u003e(()) }); tokio::join!(server, client); }); } 이 예제에서 사용한 TcpStream, TcpListener 등은 std crate가 아닌 tokio crate에 구현된 async 버전입니다. 이전 글에서 본 것과 같이, async rust를 사용하는 경우 synchronous하게 구현 된 standard library 대신 async 로 구현 된 library를 사용 해야 합니다.\nRuntime Runtime은 Future를 실행할 수 있는 환경입니다. async를 실행시키는 주체이므로 Async Executor라고도 부르는 것 같습니다. Runtime 혹은 Executor는 async를 실행시킵니다. 만약 async가 완료될 수 없는 상태라면 추후 실행 가능할 때 재 실행하고, 그 동안 다른 실행 가능한 async를 실행시켜 줍니다. 일종의 non-preemptive async task scheduler 인 것 같습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Future trait pub trait Future { type Output; fn poll(self: Pin\u003c\u0026mut Self\u003e, cx: \u0026mut Context\u003c'_\u003e) -\u003e Poll\u003cSelf::Output\u003e; } // poll 함수의 결과값 enum pub enum Poll\u003cT\u003e { // Represents that a value is immediately ready. #[lang = \"Ready\"] #[stable(feature = \"futures_api\", since = \"1.36.0\")] Ready(#[stable(feature = \"futures_api\", since = \"1.36.0\")] T), // Represents that a value is not ready yet. // // When a function returns `Pending`, the function *must* also // ensure that the current task is scheduled to be awoken when // progress can be made. #[lang = \"Pending\"] #[stable(feature = \"futures_api\", since = \"1.36.0\")] Pending, } async를 실행시키는 것은, async가 구현하고 있는 Future trait의 poll 함수를 호출하는 것을 의미합니다. async function/block/closure는 Future trait, 즉 poll 함수를 구현하고 있습니다. poll 함수가 불리면 async에 구현된 동작을 실행시키는데, async의 모든 라인이 실행 되었다면 Poll::Ready를 리턴하며 동작 완료합니다. 하지만 다른 일을 기다리는 등의 이유(e.g., I/O)로 async가 바로 완료될 수 없다면 Poll::Pending을 리턴하며 추후 재 실행되기를 기대합니다.\n1 2 3 4 5 6 7 8 9 // Future trait 실행 시 주어지는 Context. Waker는 virtual function table을 갖고 있다 pub struct Context\u003c'a\u003e { waker: \u0026'a Waker, // Ensure we future-proof against variance changes by forcing // the lifetime to be invariant (argument-position lifetimes // are contravariant while return-position lifetimes are // covariant). _marker: PhantomData\u003cfn(\u0026'a ()) -\u003e \u0026'a ()\u003e, } poll 함수의 인자로 주어지는 Context에는 Waker가 포함되어 있습니다. Waker는 Poll::Pending 시 기다리던 동작이 완료되면 이를 executor에게 알려주는 함수입니다(함수를 갖고 있습니다). Waker 는 executor-specific 합니다. Context는 async가 어디 까지 실행 되었는지를 알 수 있는 정보 또한 포함 하고 있습니다. Poll::Pending을 리턴하게 된 지점을 기억하고, Waker에 의해 재 실행된 경우 그 지점 부터 재 실행 합니다.\nasync function/block/closure 구현이 어떻게 Future::poll로 변환(?) 되는지 궁금한데 이 부분은 아직 코드 혹은 문서로 확인하지 못했어요. 기존 async 코드에서 바로 완료될 수 없는 함수를 만난 경우 혹은 코드 내에서 호출한 async의 poll도 Poll::Pending을 리턴하는 경우 Poll::Pending 을 리턴할 것 같다는 추측만 해 봅니다 ㅎㅎ\n이러한 polling 기반의 async 동작은 zero-cost futures를 가능하게 한다고 합니다!\nRuntime의 spawn이나 block_on과 같은 함수를 사용하면 async를 실행시킬 수 있습니다. 첫 번째 예제에서 사용한 futures crate의 futures::executor::block_on이 그러한 함수 중 하나 입니다. Runtime이 async를 실행 했을 때(=poll을 호출 했을 때), 그 결과가 Poll::Ready(val)인 경우 async는 실행 완료된 것이고, val를 리턴할 겁니다. 하지만 결과가 Poll::Pending이라면 어딘가에 담아 두었다, Waker가 호출된 후 재 실행할 것 입니다. 간단한 Runtime 구현은 async book의 Build an Executor를 참고하면 되겠습니다.\nRust에서 널리 사용되는 Async Runtime 들은 아래와 같습니다. tokio의 경우, std의 synchronous 동작을 asynchronous 버전(async fn)으로 구현한 버전도 제공합니다.\nTokio: A popular async ecosystem with HTTP, gRPC, and tracing frameworks. async-std: A crate that provides asynchronous counterparts to standard library components. smol: A small, simplified async runtime. Provides the Async trait that can be used to wrap structs like UnixStream or TcpListener. fuchsia-async: An executor for use in the Fuchsia OS. References Rust Async Book std thread std Future tokio io ","wordCount":"1415","inLanguage":"en","datePublished":"2022-09-11T18:53:04+09:00","dateModified":"2022-09-11T18:53:04+09:00","author":{"@type":"Person","name":"Huijeong Kim"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://huijeong-kim.github.io/post/2022-09-11-rust-async-programming/"},"publisher":{"@type":"Organization","name":"Dev. note","logo":{"@type":"ImageObject","url":"http://huijeong-kim.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://huijeong-kim.github.io/ accesskey=h title="Dev. note (Alt + H)">Dev. note</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://huijeong-kim.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://huijeong-kim.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=http://huijeong-kim.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://huijeong-kim.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://huijeong-kim.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://huijeong-kim.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Rust Async Programming</h1><div class=post-meta><span title='2022-09-11 18:53:04 +0900 +0900'>2022-09-11</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1415 words&nbsp;·&nbsp;Huijeong Kim</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#asynchronous-programming aria-label="Asynchronous Programming">Asynchronous Programming</a></li><li><a href=#concurrent-execution aria-label="Concurrent Execution">Concurrent Execution</a></li><li><a href=#asyncawait aria-label=Async/Await>Async/Await</a></li><li><a href=#runtime aria-label=Runtime>Runtime</a><ul><li><a href=#references aria-label=References>References</a></li></ul></li></ul></div></details></div><div class=post-content><p>오늘은 Rust에서 제공하는 Asynchronous Programming 관련 feature들에 대해 정리하면서, <code>async</code> 관련 포스트를 쓸 때 마다 사용되는 단어들, <code>async</code>, <code>future</code>, <code>runtime</code>, <code>executor</code>에 대해 정리해 보겠습니다. 오늘은 유독 내용이 추상적인 느낌에 부족한 부분이 많은 것 같은데, 틀린 부분이나 부족한 부분이 있다면 코멘트 남겨 주세요 :)</p><p> 
 </p><h2 id=asynchronous-programming>Asynchronous Programming<a hidden class=anchor aria-hidden=true href=#asynchronous-programming>#</a></h2><hr><p><a href=https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html>Async book</a>에는 Asynchronous programming이 다음과 같이 정의되어 있습니다.</p><p> </p><blockquote><p>Asynchronous programming, or async for short, is a <strong><u>concurrent programming model</u></strong> supported by an increasing number of programming languages. It lets you run a large number of concurrent tasks on a small number of OS threads, while preserving much of the look and feel of ordinary synchronous programming, through the <strong><u>async/await syntax</u></strong>.</p></blockquote><p> </p><p>중요 포인트는 두 가지 일 것 같습니다.</p><ul><li>OS thread 수와 관계 없이 task들을 <strong>concurrent하게 실행</strong>시킬 수 있게 하는 <strong>프로그래밍 모델</strong>이다</li><li><strong>async/await syntax</strong>를 사용하여 기존의 synchronous programming과 비슷한 look & feel을 준다</li></ul><p> 
 </p><h2 id=concurrent-execution>Concurrent Execution<a hidden class=anchor aria-hidden=true href=#concurrent-execution>#</a></h2><hr><p>Application의 task를 concurrent하게 실행하는 방법으로 가장 먼저 multi-threading을 떠올릴 수 있습니다. 가장 단순하게는, 병렬 실행할 task 마다 새로운 thread를 생성하고 그 thread에서 task를 실행시켜볼 수 있을 것입니다. <a href=https://doc.rust-lang.org/std/thread/>std::thread</a>를 사용하면 native OS thread를 생성 및 시작할 수 있습니다.</p><p>하지만 OS thread 를 사용하여 task를 병렬 실행하면 OS 의 제약 내에서 thread를 사용해야 합니다. 단일 process 당 만들 수 있는 최대 thread 수가 제한되어 있고, thread 생성 시 발생하는 overhead, thread pool 관리 등 고려 해야 할 점이 많을 것 입니다.</p><p> </p><p>많은 프로그래밍 언어에서는 <code>Green Thread</code>와 같은 OS thread 위에서 동작하는 virtual thread와 이 virtual thread를 실행시키는 환경, <code>Runtime</code>을 제공합니다. 이를 사용하면 OS thread의 제약 없이 task parallelism을 구현할 수 있고 개발자가 직접 코드에서 thread를 다루지 않아도 됩니다.</p><p>하지만 Rust의 경우, <code>Green Thread</code> 혹은 <code>Built-in Runtime</code>을 제공하지 않습니다. <code>Async/Await</code> syntax만 제공합니다. 이는 의도적인 디자인으로, 어플리케이션의 workload 에 따라 적합한(성능이 좋은) <code>Runtime</code>은 다를 수 있기 때문 입니다. Rust에는 다양한 <code>Runtime</code> Library들이 존재하고, 개발자는 이 중 application에 적합한 <code>Runtime</code>을 선택하여 async task를 실행시킬 수 있습니다.</p><p> 
 </p><h2 id=asyncawait>Async/Await<a hidden class=anchor aria-hidden=true href=#asyncawait>#</a></h2><hr><p>Rust 언어에서 제공하는 <code>Async/await</code> syntax에 대해 간단히 알아보고, 이 것이 <code>Runtime</code>에서 실행 되는 방식을 이어서 알아 보겠습니다.</p><p>The Book에서 정의한 관련 키워드들은 다음과 같습니다.</p><ul><li><code>async</code> - return a Future instead of blocking the current thread</li><li><code>await</code> - suspend execution until the result of a Future is ready</li></ul><p><code>async</code>는 <code>Future</code>를 리턴하는 asynchronous 동작(현재 thread를 blocking하지 않는 동작)을 의미하고, <code>Future</code>는 <code>Runtime</code>에서 실행될 수 있는 trait 입니다. <code>async</code> 키워드를 사용해 function, block expression, closure를 <code>Future</code>로 만들 수 있습니다. <code>Future</code> trait이 <code>Runtime</code>에서 어떻게 사용 되는지는 뒤에서 간단히 설명하겠습니다.</p><p>다음은 async func, async block, async closure를 만들어 실행시키는 간단한 코드입니다. 기존의 function, block, closure에 <code>async</code> 키워드를 추가하였고, 이를 실행시킬 <code>Runtime</code>으로는 <code>futures</code> crate를 사용했습니다. 각 <code>Future</code>들은 <code>futures::executor::block_on</code>에 의해 실행됩니다.</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>use</span> futures::executor;
</span></span><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>async_func</span>() {
</span></span><span style=display:flex><span>    println!(<span style=color:#f1fa8c>&#34;async_func&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> future1 <span style=color:#ff79c6>=</span> async_func();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> future2 <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>async</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#f1fa8c>&#34;async block&#34;</span>);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> async_closure <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>||</span> <span style=color:#ff79c6>async</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#f1fa8c>&#34;async closure&#34;</span>);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> future3 <span style=color:#ff79c6>=</span> async_closure();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    executor::block_on(future3);
</span></span><span style=display:flex><span>    executor::block_on(future2);
</span></span><span style=display:flex><span>    executor::block_on(future1);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>출력 결과</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>async closure
</span></span><span style=display:flex><span>async block
</span></span><span style=display:flex><span>async_func
</span></span></code></pre></td></tr></table></div></div><p> </p><p><code>await</code>는 Future의 동작이 완료되기를 기다릴 때 사용합니다. <code>async</code> 안에서만 사용될 수 있습니다. 다음은 3개의 task, 1) learn_song, 2) sing_song, 3) dance가 주어졌을 때, sing_song과 dance는 learn_song이 완료된 후에 실행되도록 하는 예제 코드입니다. sing_song, dance를 실행시키기 전에 <code>learn_song().await</code>를 사용하여 동작 완료를 기다립니다.</p><p><img alt=async-await loading=lazy src=../../post/2022-09-11-rust-async-programming/image04.png></p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>Song</span>(<span style=color:#8be9fd;font-style:italic>String</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>learn_song</span>() -&gt; <span style=color:#50fa7b>Song</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#f1fa8c>&#34;Learn song!&#34;</span>);
</span></span><span style=display:flex><span>    Song(<span style=color:#8be9fd;font-style:italic>String</span>::from(<span style=color:#f1fa8c>&#34;Hype boy&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>dance</span>(song: <span style=color:#ff79c6>&amp;</span><span style=color:#50fa7b>Song</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#f1fa8c>&#34;Dance to </span><span style=color:#f1fa8c>{}</span><span style=color:#f1fa8c>!!&#34;</span>, song.<span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>sing_song</span>(song: <span style=color:#ff79c6>&amp;</span><span style=color:#50fa7b>Song</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#f1fa8c>&#34;Sing a song!! </span><span style=color:#f1fa8c>{}</span><span style=color:#f1fa8c>&#34;</span>, song.<span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    futures::executor::block_on(<span style=color:#ff79c6>async</span> {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>let</span> song <span style=color:#ff79c6>=</span> learn_song().<span style=color:#ff79c6>await</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>let</span> f1 <span style=color:#ff79c6>=</span> sing_song(<span style=color:#ff79c6>&amp;</span>song);
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>let</span> f2 <span style=color:#ff79c6>=</span> dance(<span style=color:#ff79c6>&amp;</span>song);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        futures::join!(f1, f2);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>실행 결과</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Learn song!
</span></span><span style=display:flex><span>Sing a song!! Hype boy
</span></span><span style=display:flex><span>Dance to Hype boy!!
</span></span></code></pre></td></tr></table></div></div><p> </p><p><code>await</code>을 사용하여 <u>&lsquo;기다리는&rsquo;</u> 동작은 현재 thread를 blocking 하지 않고 동작을 yield 하는 방식으로 이루어집니다. 위의 예제에서는 그 동작이 잘 보이지 않을 수 있지만, I/O intensive application을 생각해 보면 이해하기 쉬울 것 입니다.</p><p>다음 예제는 rust의 대표적인 <code>Runtime</code>인 <code>tokio</code>를 사용한 TCP I/O 예시입니다. tokio runtime 생성 시 <code>new_current_thread</code>을 사용하여 현재 thread(단일 thread)만 사용하도록 했습니다. 단일 thread에서 Server 동작과 Client 동작 둘 다를 실행하고 있지만, Server 동작을 하는 async block에서 TcpListner가 <code>accept()</code>를 기다리는(await) 동안 thread를 blocking 하지 않고 동작을 yield 하므로 Client 동작의 async block에서 불리는 <code>connect()</code>가 실행될 수 있습니다.</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>use</span> tokio::io::{self, AsyncReadExt, AsyncWriteExt};
</span></span><span style=display:flex><span><span style=color:#ff79c6>use</span> tokio::net::{TcpStream, TcpListener};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    tokio::runtime::Builder::new_current_thread()
</span></span><span style=display:flex><span>        .enable_all()
</span></span><span style=display:flex><span>        .build()
</span></span><span style=display:flex><span>        .unwrap()
</span></span><span style=display:flex><span>        .block_on(<span style=color:#ff79c6>async</span> {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>let</span> addr <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;127.0.0.1:6142&#34;</span>;
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>let</span> server <span style=color:#ff79c6>=</span> tokio::spawn(<span style=color:#ff79c6>async</span> <span style=color:#ff79c6>move</span> {
</span></span><span style=display:flex><span>                <span style=color:#8be9fd;font-style:italic>let</span> listener <span style=color:#ff79c6>=</span> TcpListener::bind(<span style=color:#ff79c6>&amp;</span>addr).<span style=color:#ff79c6>await</span><span style=color:#ff79c6>?</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>loop</span> {
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd;font-style:italic>let</span> (<span style=color:#ff79c6>mut</span> socket, _) <span style=color:#ff79c6>=</span> listener.accept().<span style=color:#ff79c6>await</span><span style=color:#ff79c6>?</span>;
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd;font-style:italic>let</span> <span style=color:#ff79c6>mut</span> buf <span style=color:#ff79c6>=</span> vec![<span style=color:#bd93f9>0</span>; <span style=color:#bd93f9>1024</span>];
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>match</span> socket.read(<span style=color:#ff79c6>&amp;</span><span style=color:#ff79c6>mut</span> buf).<span style=color:#ff79c6>await</span> {
</span></span><span style=display:flex><span>                        <span style=color:#8be9fd;font-style:italic>Ok</span>(n) <span style=color:#ff79c6>=&gt;</span> { println!(<span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>{:?}</span><span style=color:#f1fa8c>&#34;</span>, buf); }
</span></span><span style=display:flex><span>                        _ <span style=color:#ff79c6>=&gt;</span> { <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>Ok</span>::<span style=color:#ff79c6>&lt;</span>_, io::Error<span style=color:#ff79c6>&gt;</span>(()); }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#8be9fd;font-style:italic>Ok</span>::<span style=color:#ff79c6>&lt;</span>_, io::Error<span style=color:#ff79c6>&gt;</span>(())
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>let</span> client <span style=color:#ff79c6>=</span> tokio::spawn(<span style=color:#ff79c6>async</span> <span style=color:#ff79c6>move</span> {
</span></span><span style=display:flex><span>                <span style=color:#8be9fd;font-style:italic>let</span> socket <span style=color:#ff79c6>=</span> TcpStream::connect(<span style=color:#ff79c6>&amp;</span>addr).<span style=color:#ff79c6>await</span><span style=color:#ff79c6>?</span>;
</span></span><span style=display:flex><span>                <span style=color:#8be9fd;font-style:italic>let</span> (<span style=color:#ff79c6>mut</span> rd, <span style=color:#ff79c6>mut</span> wr) <span style=color:#ff79c6>=</span> io::split(socket);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>                wr.write_all(<span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#34;hello</span><span style=color:#f1fa8c>\r\n</span><span style=color:#f1fa8c>&#34;</span>).<span style=color:#ff79c6>await</span><span style=color:#ff79c6>?</span>;
</span></span><span style=display:flex><span>                wr.write_all(<span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#34;world</span><span style=color:#f1fa8c>\r\n</span><span style=color:#f1fa8c>&#34;</span>).<span style=color:#ff79c6>await</span><span style=color:#ff79c6>?</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>                <span style=color:#8be9fd;font-style:italic>Ok</span>::<span style=color:#ff79c6>&lt;</span>_, io::Error<span style=color:#ff79c6>&gt;</span>(())
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            tokio::join!(server, client);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>이 예제에서 사용한 TcpStream, TcpListener 등은 std crate가 아닌 tokio crate에 구현된 async 버전입니다. <a href=https://huijeong-kim.github.io/2022/08/27/tokio-mpsc/>이전 글</a>에서 본 것과 같이, async rust를 사용하는 경우 synchronous하게 구현 된 standard library 대신 async 로 구현 된 library를 사용 해야 합니다.</p><p> 
 </p><h2 id=runtime>Runtime<a hidden class=anchor aria-hidden=true href=#runtime>#</a></h2><hr><p><code>Runtime</code>은 <code>Future</code>를 실행할 수 있는 환경입니다. <code>async</code>를 실행시키는 주체이므로 <code>Async Executor</code>라고도 부르는 것 같습니다. <code>Runtime</code> 혹은 <code>Executor</code>는 <code>async</code>를 실행시킵니다. 만약 <code>async</code>가 완료될 수 없는 상태라면 추후 실행 가능할 때 재 실행하고, 그 동안 다른 실행 가능한 <code>async</code>를 실행시켜 줍니다. 일종의 non-preemptive async task scheduler 인 것 같습니다.</p><p> </p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#6272a4>// Future trait
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>pub</span> <span style=color:#ff79c6>trait</span> Future {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>type</span> <span style=color:#50fa7b>Output</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>poll</span>(self: <span style=color:#50fa7b>Pin</span><span style=color:#ff79c6>&lt;&amp;</span><span style=color:#ff79c6>mut</span> Self<span style=color:#ff79c6>&gt;</span>, cx: <span style=color:#ff79c6>&amp;</span><span style=color:#50fa7b>mut</span> Context<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd;font-style:italic>&#39;_</span><span style=color:#ff79c6>&gt;</span>) -&gt; <span style=color:#50fa7b>Poll</span><span style=color:#ff79c6>&lt;</span>Self::Output<span style=color:#ff79c6>&gt;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// poll 함수의 결과값 enum
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>pub</span> <span style=color:#ff79c6>enum</span> <span style=color:#50fa7b>Poll</span><span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Represents that a value is immediately ready.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>#[lang = </span><span style=color:#f1fa8c>&#34;Ready&#34;</span><span style=color:#ff79c6>]</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>#[stable(feature = </span><span style=color:#f1fa8c>&#34;futures_api&#34;</span><span style=color:#ff79c6>, since = </span><span style=color:#f1fa8c>&#34;1.36.0&#34;</span><span style=color:#ff79c6>)]</span>
</span></span><span style=display:flex><span>    Ready(<span style=color:#ff79c6>#[stable(feature = </span><span style=color:#f1fa8c>&#34;futures_api&#34;</span><span style=color:#ff79c6>, since = </span><span style=color:#f1fa8c>&#34;1.36.0&#34;</span><span style=color:#ff79c6>)]</span> T),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Represents that a value is not ready yet.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// When a function returns `Pending`, the function *must* also
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// ensure that the current task is scheduled to be awoken when
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// progress can be made.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>#[lang = </span><span style=color:#f1fa8c>&#34;Pending&#34;</span><span style=color:#ff79c6>]</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>#[stable(feature = </span><span style=color:#f1fa8c>&#34;futures_api&#34;</span><span style=color:#ff79c6>, since = </span><span style=color:#f1fa8c>&#34;1.36.0&#34;</span><span style=color:#ff79c6>)]</span>
</span></span><span style=display:flex><span>    Pending,
</span></span><span style=display:flex><span>} 
</span></span></code></pre></td></tr></table></div></div><p><code>async</code>를 실행시키는 것은, <code>async</code>가 구현하고 있는 <code>Future</code> trait의 <code>poll</code> 함수를 호출하는 것을 의미합니다. async function/block/closure는 <code>Future</code> trait, 즉 <code>poll</code> 함수를 구현하고 있습니다. <code>poll</code> 함수가 불리면 <code>async</code>에 구현된 동작을 실행시키는데, <code>async</code>의 모든 라인이 실행 되었다면 <code>Poll::Ready</code>를 리턴하며 동작 완료합니다. 하지만 다른 일을 기다리는 등의 이유(e.g., I/O)로 <code>async</code>가 바로 완료될 수 없다면 <code>Poll::Pending</code>을 리턴하며 추후 재 실행되기를 기대합니다.</p><p> </p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#6272a4>// Future trait 실행 시 주어지는 Context. Waker는 virtual function table을 갖고 있다
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>pub</span> <span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>Context</span><span style=color:#ff79c6>&lt;</span><span style=color:#50fa7b>&#39;a</span><span style=color:#ff79c6>&gt;</span> {
</span></span><span style=display:flex><span>    waker: <span style=color:#ff79c6>&amp;</span><span style=color:#50fa7b>&#39;a</span> <span style=color:#50fa7b>Waker</span>,
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Ensure we future-proof against variance changes by forcing
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// the lifetime to be invariant (argument-position lifetimes
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// are contravariant while return-position lifetimes are
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// covariant).
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    _marker: <span style=color:#50fa7b>PhantomData</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>fn</span>(<span style=color:#ff79c6>&amp;</span><span style=color:#50fa7b>&#39;a</span> ()) -&gt; <span style=color:#ff79c6>&amp;</span><span style=color:#50fa7b>&#39;a</span> ()<span style=color:#ff79c6>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><code>poll</code> 함수의 인자로 주어지는 <code>Context</code>에는 <code>Waker</code>가 포함되어 있습니다. <code>Waker</code>는 <code>Poll::Pending</code> 시 기다리던 동작이 완료되면 이를 executor에게 알려주는 함수입니다(함수를 갖고 있습니다). <code>Waker</code> 는 executor-specific 합니다. <code>Context</code>는 <code>async</code>가 어디 까지 실행 되었는지를 알 수 있는 정보 또한 포함 하고 있습니다. <code>Poll::Pending</code>을 리턴하게 된 지점을 기억하고, <code>Waker</code>에 의해 재 실행된 경우 그 지점 부터 재 실행 합니다.</p><p>async function/block/closure 구현이 어떻게 <code>Future::poll</code>로 변환(?) 되는지 궁금한데 이 부분은 아직 코드 혹은 문서로 확인하지 못했어요. 기존 <code>async</code> 코드에서 바로 완료될 수 없는 함수를 만난 경우 혹은 코드 내에서 호출한 <code>async</code>의 <code>poll</code>도 <code>Poll::Pending</code>을 리턴하는 경우 <code>Poll::Pending</code> 을 리턴할 것 같다는 추측만 해 봅니다 ㅎㅎ</p><p>이러한 polling 기반의 <code>async</code> 동작은 <a href=https://blog.rust-lang.org/2019/11/07/Async-await-stable.html#zero-cost-futures>zero-cost futures</a>를 가능하게 한다고 합니다!</p><p> </p><p><code>Runtime</code>의 spawn이나 block_on과 같은 함수를 사용하면 <code>async</code>를 실행시킬 수 있습니다. 첫 번째 예제에서 사용한 futures crate의 <code>futures::executor::block_on</code>이 그러한 함수 중 하나 입니다. <code>Runtime</code>이 <code>async</code>를 실행 했을 때(=<code>poll</code>을 호출 했을 때), 그 결과가 <code>Poll::Ready(val)</code>인 경우 <code>async</code>는 실행 완료된 것이고, val를 리턴할 겁니다. 하지만 결과가 <code>Poll::Pending</code>이라면 어딘가에 담아 두었다, <code>Waker</code>가 호출된 후 재 실행할 것 입니다. 간단한 <code>Runtime</code> 구현은 async book의 <a href=https://rust-lang.github.io/async-book/02_execution/04_executor.html>Build an Executor</a>를 참고하면 되겠습니다.</p><p> </p><p>Rust에서 널리 사용되는 <a href="https://rust-lang.github.io/async-book/08_ecosystem/00_chapter.html?highlight=tokio#popular-async-runtimes">Async Runtime</a> 들은 아래와 같습니다. tokio의 경우, std의 synchronous 동작을 asynchronous 버전(async fn)으로 구현한 버전도 제공합니다.</p><ul><li><strong>Tokio</strong>: A popular async ecosystem with HTTP, gRPC, and tracing frameworks.</li><li><strong>async-std</strong>: A crate that provides asynchronous counterparts to standard library components.</li><li><strong>smol</strong>: A small, simplified async runtime. Provides the Async trait that can be used to wrap structs like UnixStream or TcpListener.</li><li><strong>fuchsia-async</strong>: An executor for use in the Fuchsia OS.</li></ul><p> 
 </p><h3 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h3><hr><ul><li><a href=https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html>Rust Async Book</a></li><li><a href=https://doc.rust-lang.org/std/thread/index.html>std thread</a></li><li><a href=https://doc.rust-lang.org/std/future/trait.Future.html>std Future</a></li><li><a href=https://tokio.rs/tokio/tutorial/io>tokio io</a></li></ul><p> 
 </p></div><footer class=post-footer><ul class=post-tags><li><a href=http://huijeong-kim.github.io/tags/async-rust/>Async Rust</a></li></ul><nav class=paginav><a class=prev href=http://huijeong-kim.github.io/post/2023-01-29-rust-polymorphism/><span class=title>« Prev</span><br><span>Polymorphism in Rust</span>
</a><a class=next href=http://huijeong-kim.github.io/post/2022-08-28-parameterised-test/><span class=title>Next »</span><br><span>Rust로 Parameterised Test 작성하기</span></a></nav></footer><script src=https://utteranc.es/client.js repo=huijeong-kim/huijeong-kim.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=http://huijeong-kim.github.io/>Dev. note</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>